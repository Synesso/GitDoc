# What I've done

In this section very briefly (1 or 2 lines) describe what you've done in this turn.

- Created `src/lib/layout-thread-cards.ts` — `layoutThreadCards(threads, container, cardHeights?)` function that computes vertical positions for comment thread cards in the right sidebar. Exports `getThreadAnchorY(thread, container)` which finds the DOM element matching a thread's target line via `[data-source-start]`/`[data-source-end]` attributes and returns its vertical midpoint relative to the container. The layout algorithm sorts threads by desired Y position, then pushes overlapping cards downward with a minimum 8px gap (Google Docs–style push-apart). Accepts an optional `cardHeights` map for actual measured heights (via `ResizeObserver` or refs) instead of the 100px default estimate. Each result includes `desiredY`, `actualY`, and `displaced` flag. Exports `PositionedThread` interface. Verified production build passes.
- Created `src/lib/build-comment-threads.ts` — `buildCommentThreads(comments, filePath)` function that groups a flat list of REST PR review comments into `CommentThread[]` for a specific file. Filters to `side === "RIGHT"` comments on the given file path. Top-level comments (no `inReplyToId`) anchor threads; replies attach via `inReplyToId`. Orphaned replies (parent on different file/side) are silently dropped. Comments within each thread are sorted by `createdAt` ascending. Threads are sorted by `line` number (top of document first). Exports `CommentThread` interface with `id`, `path`, `line`, `startLine`, `comments`, and `isResolved` (always `false` for REST-only fallback). Verified production build passes.
- Created `src/lib/comment-drafts.ts` — `saveDraft`, `loadDraft`, `clearDraft` functions that persist comment text to `sessionStorage` keyed by `gitdoc:draft:{prNumber}:{filePath}:{lineRange}`. Drafts expire after 1 hour. All operations are wrapped in try/catch for environments where `sessionStorage` is unavailable. Updated `CommentForm` to accept optional `prNumber`/`filePath` props; when provided, the form auto-saves drafts on every keystroke, restores a saved draft as the initial body on mount, clears the draft on successful submit, and shows a "Restored unsaved comment" indicator when a draft was pre-filled. Verified production build passes.
- Created `src/lib/api-error.ts` — `ApiError` class that categorises errors into `validation`, `auth`, `rate_limit`, `transient`, `network`, `unknown` with `status`, `retryAfter`, `isRateLimit` fields. Also exports `parseApiError(res)` (classifies an HTTP response by status code and rate-limit headers) and `parseRetryAfter(res)` (extracts seconds-until-reset from `x-ratelimit-reset` or `Retry-After` headers). Created `src/lib/post-comment.ts` — `postComment(baseUrl, params)` helper that POSTs a PR review comment with retry logic: 3 attempts with exponential backoff (1s, 2s) for transient (5xx) and network errors; immediate throw for non-retryable errors (422 validation, 401 auth, 404 not found); rate-limit errors (429, 403 with remaining=0) throw immediately with `retryAfter` metadata for UI countdown display. Returns typed `PostCommentResult`. Verified production build passes.
- Created `src/hooks/use-pr-comments.ts` — `usePRComments` SWR-backed hook for fetching and mutating PR review comments. Installed `swr` dependency. Exports `PRComment` interface matching API route camelCase shape (with optional `isPending` flag for optimistic entries). Fetches from `GET /api/repos/.../comments` with optional `?path=` filter, 30s polling via `refreshInterval`, and `revalidateOnFocus`. Provides `submitComment()` that posts via `fetch` to the comments API and uses SWR's `mutate()` with `optimisticData` (appends a temp comment with `isPending: true`), `rollbackOnError: true`, `populateCache: true` (replaces optimistic entry with server response), and `revalidate: true`. Accepts `currentUser` for optimistic attribution. Returns `{ comments, isLoading, error, submitComment, refreshComments }`. Verified production build passes.
- Created `src/hooks/use-comment-highlight.ts` — `useCommentHighlight` hook that applies a `comment-target-highlight` CSS class to rendered markdown elements whose `data-source-start`/`data-source-end` range falls within the stored `SelectionInfo` line range. Acts as a visual substitute for the native browser selection (which clears when the comment form textarea gains focus). Uses `querySelectorAll('[data-source-start]')` to find annotated elements, checks overlap with `startLine`/`endLine`, and adds/removes the class via a `useEffect` cleanup. Added corresponding CSS in `globals.css` with light mode (warm yellow `oklch(0.9 0.05 90 / 40%)`) and dark mode (`oklch(0.5 0.05 90 / 20%)`) variants, 2px border-radius, and 150ms transition. Verified production build passes.
- Created `src/components/comment-form.tsx` — `CommentForm` client component with `role="dialog"` `aria-modal="false"` non-modal dialog pattern. Accepts `selectionInfo`, `onSubmit`, `onCancel`, and optional `isSubmitting` props. Features: auto-focused `Textarea` on mount; `aria-describedby` with hidden context announcing "Commenting on lines N–M: 'selected text…'" for screen readers; Escape key to cancel; Cmd/Ctrl+Enter to submit; Submit button disabled when body is empty or submitting; "Posting…" label during submission. Uses shadcn `Button` and `Textarea` components. Verified production build passes.
- Added `isCommentFormOpen` guard to `CommentAnchorButton` — new optional `isCommentFormOpen` prop (default `false`). When `true`, the `onClearSelection` callback is suppressed, preventing the stored `SelectionInfo` from being wiped when the browser clears the native selection on textarea focus. The `onClearSelection` callback's dependency array includes `isCommentFormOpen` so the hook re-subscribes when the flag changes. Verified production build passes.
- Created `src/components/comment-anchor-button.tsx` — `CommentAnchorButton` client component that wires `useSelectionObserver` + `extractSelectionInfo` to show a floating "Add comment" button in the right margin at the selection's vertical position. Accepts `containerRef`, `commentableLines`, and `onComment` props. For commentable selections, renders a `MessageSquarePlus` icon button (shadcn `Button` + `Tooltip`) positioned absolutely via `anchorTop` from `SelectionInfo` relative to the container. For non-commentable selections, shows a dismissible hint ("This passage wasn't changed in this PR") that auto-dismisses after 4 seconds. Hidden when no selection exists. Verified production build passes.
- Created `src/lib/snap-to-commentable-lines.ts` — `snapToCommentableLines(selectionInfo)` function that converts a `SelectionInfo` (which already contains the sorted `commentableLines` array) into a `CommentLineRange` with `line` (last commentable line) and optional `startLine` (first commentable line, omitted for single-line comments) suitable for the GitHub PR review comment API. Returns `null` if no commentable lines exist. Verified production build passes.
- Created `src/lib/extract-selection-info.ts` — `extractSelectionInfo(range, commentableLines)` function that converts a live DOM `Range` into a plain `SelectionInfo` object before any focus shift. Uses `findSourceElement()` to resolve both range endpoints to annotated ancestor elements with `[data-source-start]`/`[data-source-end]` attributes. Extracts `startLine`/`endLine`, `selectedText` (via `range.toString()`), `anchorTop` (via `getBoundingClientRect()` + `scrollY`), and computes `isCommentable` + `commentableLines` array by iterating the line range against the provided `Set<number>`. Returns `null` if endpoints lack source-line annotations. Exports `SelectionInfo` interface. Verified production build passes.
- Created `src/lib/find-source-element.ts` — `findSourceElement(node)` utility that walks from a DOM node (typically a Text node from `Range.startContainer`/`Range.endContainer`) up to the nearest ancestor Element with a `[data-source-start]` attribute via `closest()`. Handles both Text nodes (which lack `closest()`) and Element nodes. Verified production build passes.
- Created `src/hooks/use-selection-observer.ts` — `useSelectionObserver` hook that listens to `selectionchange` + `mousedown`/`mouseup` on `document`, applies input-aware debouncing (10ms after mouseup for mouse selections, 100ms for keyboard/programmatic via `selectionchange`), ignores intermediate drag events while mouse is held. Calls `onSelection(range)` for valid non-collapsed selections within the container, `onClearSelection()` when selection is cleared. Follows Hypothesis annotation tool pattern. Verified production build passes.
- Created `src/lib/rehype-commentable.ts` plugin — walks the hast tree after `rehype-source-lines` and `rehype-code-source-lines`, checks each element's `dataSourceStart`/`dataSourceEnd` range against a provided `Set<number>` of commentable lines, and sets `dataCommentable="true"` on elements that overlap at least one commentable line. Updated `MarkdownRenderer` to accept an optional `commentableLines` prop and conditionally wire the plugin into the rehype pipeline. Verified production build passes.
- Created `src/lib/commentable-lines.ts` with `getCommentableLines(file)` function — takes a `PrFile` object (from the files API route), parses its `patch` field with `parse-diff`, and returns either `{ readOnly: false, lines: Set<number> }` with commentable line numbers (`add` → `ln`, `normal` → `ln2`) or `{ readOnly: true, reason: string }` for non-commentable files. Handles absent `patch` field (binary/large diffs), deleted files (`status: "removed"`), and renamed-with-no-changes (0 additions + 0 deletions + no patch). Prepends minimal diff header to GitHub's hunk-only `patch` string for `parse-diff` compatibility. Exports `PrFile`, `CommentableResult`, `ReadOnlyResult`, and `CommentableLinesResult` types. Verified production build passes.
- Installed `parse-diff` (v0.11.1, MIT, zero dependencies, ships its own TypeScript definitions) — parses unified diff strings from GitHub's `patch` field into structured per-line change objects (`AddChange`, `DeleteChange`, `NormalChange`). Verified production build passes.
- Created `src/lib/url-transform.ts` with `makeUrlTransform()` function — rewrites relative image paths to `raw.githubusercontent.com/{owner}/{repo}/{headSha}/...` and relative `.md`/`.mdx` links to GitHub blob view (`github.com/{owner}/{repo}/blob/{headSha}/...`). Passes absolute URLs, data URIs, and anchor-only links through unchanged. Uses `defaultUrlTransform` from `react-markdown` for safety checks. Handles repo-root-relative (`/images/foo.png`) and directory-relative (`./img.png`, `../assets/bar.png`) paths via `URL` constructor. Updated `MarkdownRenderer` to accept optional `owner`/`repo`/`headSha`/`filePath` props and wire `urlTransform` when all are provided. Verified production build passes.
- Created `src/components/markdown-renderer.tsx` — a `"use client"` component that configures the full rehype plugin pipeline in the correct order: (1) `rehypeSourceLines` annotates all elements with `data-source-start`/`data-source-end`, (2) `rehypePrismPlus` with `ignoreMissing: true` syntax-highlights code and wraps each line in `<span class="code-line">`, (3) `rehypeCodeSourceLines` annotates those code-line wrappers with correct source line numbers. Also wires `remarkGfm` for GFM support and wraps output in `<article className="prose dark:prose-invert lg:prose-lg max-w-none">` for typography. Verified production build passes.
- Installed `rehype-prism-plus` (v2.0.2, ~780K weekly downloads) as the code line-wrapping plugin. It handles both Prism-based syntax highlighting AND per-line wrapping in one plugin — produces `<div class="code-line">` wrappers that the existing `rehype-code-source-lines` plugin targets. Chosen over `rehype-highlight` + `rehype-highlight-code-lines` combo due to far higher adoption and single-plugin simplicity. Verified production build passes.
- Created `src/lib/rehype-code-source-lines.ts` plugin — visits all `<pre>` elements, finds the child `<code>`, then walks its children for elements with `code-line` class (produced by line-wrapping plugins). Annotates each with `dataSourceStart`/`dataSourceEnd` computed as `fenceStartLine + 1 + lineIndex`. Must run after a line-wrapping plugin like `rehype-prism-plus` or `rehype-highlight-code-lines`. Verified production build passes.
- Confirmed `react-markdown`, `remark-gfm` already installed (from scaffolding); `remark-rehype` available as transitive dep. Marked task complete. Created `src/lib/rehype-source-lines.ts` plugin — uses `unist-util-visit` to walk the hast tree and copy `position.start.line`/`position.end.line` into `dataSourceStart`/`dataSourceEnd` properties on every element node (rendered as `data-source-start`/`data-source-end` HTML attributes). Verified production build passes.
- Created `POST /api/repos/[owner]/[repo]/pulls/[pull_number]/threads/[threadId]/resolve` route — calls `resolveReviewThread` GraphQL mutation with the thread's node ID. Returns `{ graphqlId, isResolved, resolvedBy }`. Same error handling pattern as the threads GET route (GraphQL errors → 422, HTTP 401/403 passthrough). Verified production build passes.
- Created `POST /api/repos/[owner]/[repo]/pulls/[pull_number]/threads/[threadId]/unresolve` route — calls `unresolveReviewThread` GraphQL mutation. Returns `{ graphqlId, isResolved }` (no `resolvedBy` since thread is no longer resolved). Same error handling pattern as the resolve route. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls/[pull_number]/threads` route — fetches all PR review threads via GitHub GraphQL API using the `PullRequest.reviewThreads` connection. Paginates through all threads (100 per page). Returns pre-grouped `{ threads: CommentThread[] }` with `graphqlId`, `isResolved`, `resolvedBy`, `viewerCanResolve`, `viewerCanUnresolve`, `isOutdated`, `path`, `line`, `startLine`, `diffSide`, `subjectType`, and nested `comments[]` (with `databaseId`, `body`, `author`, `createdAt`, `outdated`, `diffHunk`). Supports optional `?path=` query param for server-side filtering. Error handling for GraphQL errors, 401, 403. Verified production build passes.
- Created `src/lib/graphql.ts` with `githubGraphQL()` helper — simple typed `fetch` wrapper for `POST https://api.github.com/graphql` with Bearer token auth. Exports `githubGraphQL<T>(token, query, variables)` that returns `T` from `json.data`. Throws `GitHubGraphQLError` (with structured `errors` array) on GraphQL errors, and a plain `Error` on HTTP-level failures. Also exports `GraphQLError` interface and `GitHubGraphQLError` class. No caching (POST requests don't support ETags; caching will be done at the route level). Verified production build passes.
- Consolidated pagination handling for files and comments routes — both already aggregated all pages via `parseLinkHeader` + `while` loop with `per_page=100`. Extracted the duplicated `parseLinkHeader()` utility from both route files into the shared `lib/github.ts` module. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls` route — lists open PRs, proxies to GitHub with 30s cache TTL + ETag, maps response to `{ pulls: [{ number, title, user: { login, avatarUrl }, headSha, updatedAt, draft }] }`. Supports `?page=` query param. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls/[pull_number]` route — returns single PR detail `{ number, title, state, draft, headSha, baseSha }`. 30s cache TTL + ETag. Follows same pattern as pulls list route. Verified production build passes.
- Created `src/lib/github.ts` — GitHub API proxy layer with three exports: `githubFetch()` (handles Authorization header, ETag conditional requests via `If-None-Match`, LRU cache with `lru-cache` npm package at ~500 entries/50MB, configurable TTL per entry, supports both relative and absolute GitHub URLs), `classifyGitHubError()` (classifies HTTP errors into `validation`/`auth`/`rate_limit`/`transient`/`unknown` categories with SAML SSO detection and `retryAfter` computation), and `buildProxyResponse()` (forwards `x-ratelimit-remaining`/`x-ratelimit-reset` headers to frontend). Installed `lru-cache` dependency. Verified production build passes.
- Created `src/middleware.ts` — Next.js middleware that intercepts all `/api/repos/*` requests and returns 401 JSON if the `gitdoc_session` cookie is absent. Optimistic auth gate that avoids running full route handlers for unauthenticated requests. Verified production build passes.
- Created `GET /api/auth/me` route at `src/app/api/auth/me/route.ts`. Returns `{ login, avatarUrl, name }` from the session if authenticated, or 401 if not. Added `name` field to `SessionData` and updated the callback route to store `userData.name` from the GitHub user profile. Verified production build passes.
- Created `GET /api/auth/logout` route at `src/app/api/auth/logout/route.ts`. Calls `session.destroy()` to clear the encrypted iron-session cookie, then redirects to `/`. Verified production build passes.
- Researched architecture options and GitHub API for PR review comments. Wrote initial architecture section in design.md covering stack (Next.js + react-markdown), API endpoints, auth model, and the critical diff-line constraint.
- Researched diff-line mapping: how to fetch the diff via `GET /pulls/{n}/files` (returns `patch` field), parse it with `parse-diff` npm package, and build a set of commentable line numbers for each file.
- Researched source-line tracking: traced how position data flows through the unified pipeline (mdast → hast → React), designed a `rehype-source-lines` plugin to attach `data-source-start`/`data-source-end` attributes to rendered DOM elements.

- Researched text selection UX: how to detect text selection via browser Selection API, map DOM selections back to source lines using `closest('[data-source-start]')`, position a floating comment anchor via `Range.getBoundingClientRect()`, and cross-reference with commentable diff lines.

- Researched resolving relative image paths: use `react-markdown`'s `urlTransform` prop to rewrite relative `src`/`href` URLs to `raw.githubusercontent.com/{owner}/{repo}/{headSha}/{path}`. Designed strategy for `.md` links (point to GitHub blob view), private repos (API proxy), and path resolution using `URL` constructor.

- Researched UI framework/component library: Recommended **Tailwind CSS + shadcn/ui** (Radix UI primitives). Identified key shadcn components needed (Popover, Card, Avatar, Collapsible, ScrollArea, etc.) and the critical need for `@tailwindcss/typography` plugin (`prose` classes) to style `react-markdown` output. Designed two-column layout (rendered markdown + comment margin).

- Researched visual indication of commentable vs non-commentable regions. Designed a 4-layer approach: (1) subtle left-margin gutter bars on commentable blocks using `data-commentable` attribute + CSS `border-left`, (2) hover highlight on commentable elements only, (3) selection-time feedback — show comment anchor only when commentable lines exist, with tooltip for non-commentable selections, (4) comment-count badges in gutter. Evaluated and rejected alternatives: full background tinting (too visually heavy), selection-only feedback (poor discoverability), opacity dimming (hurts readability), and reading/review mode toggle (future enhancement).

- Researched comment attribution and authentication model. Both OAuth App tokens and GitHub App user-access tokens attribute PR review comments to the authenticated user. OAuth App: no badge, long-lived tokens, broad `repo` scope. GitHub App: small identicon badge on avatar, 8-hour token expiry + 6-month refresh tokens, fine-grained permissions (`pull_requests: write` + `contents: read`). Designed the full auth section with OAuth flow, token storage (encrypted HTTP-only cookies), Next.js API route structure, and `next-auth` recommendation.

- Researched deployment & hosting options. Recommended **Vercel** as primary target — zero-config Next.js integration, serverless model fits the stateless architecture (no DB), preview deploys per PR, encrypted env vars for OAuth secrets. Docker standalone (`output: 'standalone'`) as self-hosted fallback for container platforms. OpenNext for AWS Lambda+CloudFront if AWS-native needed. No Block-internal infrastructure requirement identified in the PRD. Edge Runtime deferred — `next-auth`/`iron-session` may need Node.js runtime for crypto APIs.

- Researched caching strategy for GitHub API rate limits. Designed a 4-layer approach: (1) GitHub conditional requests via ETags — 304 responses don't count against rate limits, most impactful optimization; (2) SHA-keyed immutable content cache — file content at a commit SHA never changes, cache indefinitely; (3) short-TTL cache for dynamic data (PR lists 30–60s, comments 10–15s with ETags); (4) client-side SWR/TanStack Query for deduplication, stale-while-revalidate, and optimistic updates. Server-side implementation uses `lru-cache` npm package with bounded memory. Addressed serverless considerations (Vercel cold starts lose in-memory cache, Vercel KV as upgrade path).

- Researched handling of missing/truncated `patch` fields for large diffs. Documented GitHub's diff limits (300 files, 20K lines, 1MB total, 500KB per file), detection strategy for absent `patch`, read-only mode UI behavior, and fallback options. Designed `getCommentableLines()` function that returns `readOnly: true` when patch is missing.

- Evaluated auth libraries: Auth.js (next-auth v5) vs `iron-session` vs Better Auth. **Recommended `iron-session`** for manual GitHub OAuth — minimal abstraction (~50 lines of auth code), direct token access for API proxying, no database needed, ~5KB bundle, Edge-compatible. Auth.js is in maintenance mode (joined Better Auth Sep 2025, v5 still in beta). Better Auth is over-engineered for GitDoc's single-provider needs. Updated environment variables (removed `NEXTAUTH_URL`/`NEXTAUTH_SECRET`, added `NEXT_PUBLIC_APP_URL`). Updated Edge Runtime section — `iron-session/edge` is Edge-compatible.

- Researched line-level commenting within fenced code blocks. The default hast structure is a single `pre > code > text` node — no per-line granularity. Solution: use a line-wrapping plugin (`rehype-prism-plus` or `rehype-highlight-code-lines`) to split code into per-line `<span>` elements, then a custom `rehype-code-source-lines` plugin to annotate each line with `data-source-start` computed from the code block's `position.start.line + 1` (skipping the fence line). This integrates with the existing `closest('[data-source-start]')` selection system.

- Researched keyboard-based text selection handling. Studied the Hypothesis annotation client's `SelectionObserver` pattern. Replaced the earlier `selectstart` + `mouseup` approach with a unified `selectionchange`-based strategy using mouse-state tracking and input-aware debouncing (10ms for mouse, 100ms for keyboard). This handles all selection methods (Shift+Arrow, Caret Browsing, assistive tech, programmatic) without special-casing. Updated the Event Handling Strategy section in design.md with a complete `useSelectionObserver` React hook and comparison table.

- Researched touch device support for select-to-comment. Studied Hypothesis client source code (`selection-observer.ts`, `adder.tsx`, `user-agent.ts`) to understand their touch handling approach. Key finding: no explicit `touchend`/`touchstart` listeners needed — `selectionchange` fires universally on touch devices. `touchend` does NOT fire when mobile browsers enter text selection mode. Native selection toolbar (Copy/Paste/Select All) appears ABOVE selection on both iOS Safari and Android Chrome — position custom comment anchor BELOW to avoid conflict. Detect touch via `(pointer: coarse)` CSS media query. Recommended desktop-first MVP with mobile as read-only/degraded commenting. Added two new exploration tasks: responsive layout design and selection range preservation on focus shift.

- Researched SAML SSO handling for GitHub API tokens. Key finding: **OAuth App and GitHub App tokens are "automatically authorized for SAML SSO"** per GitHub's official docs — this is NOT a concern for MVP. Only Personal Access Tokens (classic) require manual SSO authorization. For post-MVP GitHub App migration, there's a nuance: credential authorizations are created per-org at authorization time based on active SSO sessions. Documented the `X-GitHub-SSO` response header format (provides re-auth URLs) and recovery flow for detecting/guiding users through SSO issues.

- Researched responsive layout design for the two-column layout on mobile viewports (<768px). Evaluated three options: stacked layout (rejected — breaks spatial anchoring), collapsible right sidebar (rejected for phones — covers content), and bottom drawer (recommended). Designed the mobile layout using shadcn/ui's `Drawer` component (built on Vaul), with `useMediaQuery` hook for responsive component switching. Documented mobile comment entry points (floating badge, inline gutter indicators, drawer-based thread viewing), header adaptation, typography responsiveness, and edge cases (orientation change, SSR mismatch, virtual keyboard). Added two new exploration tasks: accessibility audit and error handling/optimistic UI.

- Researched selection range preservation when focus shifts to comment textarea. Key finding: DOM `Range` objects hold live node references that become stale on re-render, and `cloneRange()` clones references not nodes. Designed a `SelectionInfo` plain-data model (startLine, endLine, selectedText, anchorTop, isCommentable, commentableLines) extracted immediately on selection detection. Designed state management pattern with `isCommentFormOpen` guard to prevent `onClearSelection` from wiping stored line data when textarea gains focus. Added CSS highlight class pattern as visual substitute for cleared native selection (mirrors Google Docs yellow highlight).

- Researched WCAG 2.1 AA accessibility requirements for the commenting UX. Designed 8-area accessibility approach: (1) commentable region access via visually-hidden `<button>` elements (not `aria-label` on prose — that overrides text content); (2) WAI-ARIA feed pattern for comment thread lists with Page Down/Up navigation; (3) non-modal dialog focus management for comment input forms; (4) `aria-live` regions for status messages (success/error/loading); (5) keyboard-only commenting workflow; (6) WCAG 1.4.13 compliance for hover-triggered content via Radix Tooltip; (7) ARIA landmark regions for page structure; (8) color contrast requirements for gutter bars and highlights.

- Researched stale SHA detection & auto-refresh. Designed polling-based approach using `GET /pulls/{n}` with ETag conditional requests (304s don't count against rate limits). Poll every 60s via SWR's `refreshInterval`. On SHA change: show a non-intrusive banner prompting user to refresh (don't auto-refresh to protect unsaved drafts and reading context). Designed full re-sync flow: save drafts → re-fetch content + diff → rebuild commentable lines → re-render → restore drafts. Evaluated and rejected webhooks/SSE for MVP (require server push infrastructure, GitHub has no public real-time API). Also handles PR closed/merged detection via `state` field.

- Designed complete Next.js API route structure for the GitHub proxy layer. 12 routes total: 4 auth, 7 GitHub proxy, 1 content/image proxy. Designed shared helpers (`requireAuth()`, `githubFetch()`, `classifyGitHubError()`), middleware, standardised error format, request processing pipeline, and full route-by-route specification with request/response schemas.
- Initialized Next.js project under `app/` directory using `create-next-app@latest` with App Router, TypeScript, Tailwind CSS v4, ESLint, Turbopack, and `src/` directory layout. Next.js 16.1.3, React 19.2.3. Updated metadata to GitDoc branding. Verified successful production build.
- Installed and configured shadcn/ui via `npx shadcn@latest init` (new-york style, Tailwind v4, OKLCH colors). Added all 14 required components: Button, Card, Popover, Drawer (Vaul), Collapsible, Avatar, Tooltip, Skeleton, Badge, ScrollArea, Dialog, Sonner, DropdownMenu, Textarea. Dependencies installed: radix-ui, class-variance-authority, clsx, tailwind-merge, lucide-react, vaul, sonner, next-themes, tw-animate-css. Fixed duplicate `@apply` lines in globals.css. Verified successful production build.
- Installed `@tailwindcss/typography` plugin as a dev dependency and added `@plugin "@tailwindcss/typography"` to `globals.css` (Tailwind v4 CSS-first config). Provides `prose` / `dark:prose-invert` / `prose-lg` classes for styling `react-markdown` output. Verified production build passes.
- Set up environment variables: created `.env.local.example` with `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`, `SESSION_SECRET`, `NEXT_PUBLIC_APP_URL` (with generation instructions). Created `src/lib/env.ts` with lazy getter-based validation that throws descriptive errors on missing vars. `.env*` files already in `.gitignore`.
- Created `src/lib/session.ts` with `getSession()` and `requireAuth()` helpers using `iron-session` v8. `getSession()` returns an encrypted session from HTTP-only cookies (30-day TTL, `sameSite: lax`, secure in production). `requireAuth()` returns a discriminated union — either `{ session }` with a guaranteed `githubToken` or `{ error: Response }` with a 401 JSON response. Uses `env.SESSION_SECRET` from the validated env module. `iron-session` was already installed from scaffolding. Verified production build passes.
- Created `GET /api/auth/login` route at `src/app/api/auth/login/route.ts`. Generates a `state` via `crypto.randomUUID()`, stores it alongside an optional `returnTo` path in a short-lived `oauth_state` cookie (10 min, httpOnly, sameSite lax). Redirects to `https://github.com/login/oauth/authorize` with `client_id`, `state`, `scope=repo`, and `redirect_uri`. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls/[pull_number]/files` route — lists changed files in a PR, filtered server-side to `.md`/`.mdx` only. Paginates through all pages via GitHub's `Link` header (handles >100 files). Returns `{ files: [{ filename, status, additions, deletions, patch, sha }] }` with `patch` set to `null` when absent (large diff fallback). Forwards rate-limit headers from the last upstream response. 30s cache TTL + ETag. Verified production build passes.
- Created `GET /api/auth/callback` route at `src/app/api/auth/callback/route.ts`. Validates `code` and `state` query params, checks `state` against the `oauth_state` cookie (CSRF protection), exchanges `code` for an access token via `POST https://github.com/login/oauth/access_token`, fetches user profile (`login`, `avatar_url`) via `GET /user`, stores token + user info in encrypted `iron-session` cookie, clears `oauth_state` cookie, and redirects to `returnTo` path. Also fixed a pre-existing issue in `session.ts` where `sessionOptions` eagerly evaluated `env.SESSION_SECRET` at module load time (breaking builds without env vars) — changed to a lazy `getSessionOptions()` function. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls/[pull_number]/comments` route — lists PR review comments with pagination (aggregates all pages via Link header), 10s cache TTL + ETag, optional `?path=` query param for server-side filtering by file path. Maps GitHub snake_case to camelCase response: `{ comments: [{ id, body, user: { login, avatarUrl }, path, line, startLine?, side, inReplyToId?, createdAt, updatedAt }] }`. Forwards rate-limit headers. Verified production build passes.
- Created `POST /api/repos/[owner]/[repo]/pulls/[pull_number]/comments` route — creates a new PR review comment. Accepts camelCase body `{ body, path, line, commitId, startLine? }`, validates required fields (rejects empty body with 422), maps to GitHub snake_case (`commitId` → `commit_id`, `startLine` → `start_line`), adds `side: "RIGHT"` automatically. For multi-line comments, also sets `start_side: "RIGHT"`. Returns `{ id, body, user: { login, avatarUrl }, path, line, startLine?, createdAt }` with 201 status. Forwards rate-limit headers. Verified production build passes.
- Created `POST /api/repos/[owner]/[repo]/pulls/[pull_number]/comments/[comment_id]/replies` route — replies to an existing comment thread. Accepts `{ body }`, validates non-empty body (422). Proxies to GitHub's reply endpoint (only requires `body`). Returns `{ id, body, user: { login, avatarUrl }, path, line, startLine?, inReplyToId?, createdAt }` with 201 status. Forwards rate-limit headers. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/pulls/[pull_number]/head` route — lightweight endpoint returning only `{ headSha, state }` for stale-SHA polling. Uses 15s cache TTL (shorter than the 30s on the full PR detail route) since this is polled frequently. Same auth/error/rate-limit pattern as other routes. Verified production build passes.
- Created `GET /api/repos/[owner]/[repo]/contents/[...path]` route — fetches file content at a specific ref via GitHub Contents API. Requires `?ref=` query param (commit SHA). For text files: fetches base64-encoded content, decodes to UTF-8, returns `{ content, sha, encoding: "utf-8" }`. Uses SHA-keyed immutable caching (no TTL — stays until LRU eviction). For image files (`.png`, `.jpg`, `.jpeg`, `.gif`, `.svg`, `.webp`, `.ico`, `.bmp`): acts as image proxy — fetches raw bytes via `Accept: application/vnd.github.raw+json`, streams with correct `Content-Type` and `Cache-Control: public, max-age=31536000, immutable`. Forwards rate-limit headers. Verified production build passes.

# Things I've learned

- GitHub PR review comments can ONLY target lines in the diff (added/removed/context lines), not arbitrary file lines. This is a fundamental UX constraint — the app must know which rendered passages map to diff lines.
- The `line` parameter in the create-comment API refers to the line number in the blob (source file), not the diff position. The old `position` parameter (diff-relative) is deprecated.
- `side: "RIGHT"` is used for additions/new lines; `side: "LEFT"` for deletions. For GitDoc (showing head-ref only), we always use `RIGHT`.
- `react-markdown` built on `remark`/`rehype` provides AST `position` info (start.line, end.line) which can be used for source-line tracking.
- GitHub OAuth App gives `repo` scope (broad); GitHub App allows fine-grained `pull_requests: write` + `contents: read`. Both support user-access tokens so comments appear as the authenticated user.
- `sq codesearch` CLI does not exist; no internal code search tool was found via `sq`.
- The `patch` field in the list-files response is a standard unified diff with 3 context lines. There is NO GitHub API parameter to increase context lines.
- `parse-diff` npm package (MIT, zero deps, ~1M weekly downloads) returns structured data per change: `AddChange` has `ln` (new-file line), `NormalChange` has `ln2` (new-file line), `DeleteChange` has `ln` (old-file line). For GitDoc (showing head-ref), commentable lines = all `AddChange.ln` + all `NormalChange.ln2`.
- New files (`status: "added"`) have the entire file in the diff, so every line is commentable.
- Very large diffs may have the `patch` field absent/truncated — need graceful fallback to read-only.
- Position data (source line numbers) is preserved through the entire unified pipeline: remark parses markdown into mdast with `position` on every node; `mdast-util-to-hast` copies position via an internal `patch()` function to hast nodes; `react-markdown` exposes the hast `node` (with position) as a prop to custom components.
- A simple rehype plugin using `unist-util-visit` can walk the hast tree and set `data-source-start`/`data-source-end` properties on all element nodes — these become HTML data attributes in the rendered DOM.
- Two approaches exist: (1) rehype plugin (cleaner, applies to all elements automatically), (2) custom `components` prop on `react-markdown` (more boilerplate but finer control). Recommend rehype plugin.
- Fenced code blocks are a special case: the whole block becomes one `pre > code` element. Per-line commenting within code blocks would require splitting the text content by newlines — a separate task.
- hast `text` nodes don't become DOM elements, so line tracking relies on the enclosing element's position data.
- The browser Selection API returns `anchorNode`/`focusNode` which are usually **Text nodes** (not Elements). To find our `data-source-start` attributes, we must use `node.parentElement.closest('[data-source-start]')` since Text nodes don't have `closest()`.
- Best event strategy for select-to-comment: `selectstart` to clear stale UI + `mouseup` to read the final selection. `selectionchange` fires continuously during drag and causes jumpy repositioning — not ideal for a comment button that should appear only after selection completes.
- `Range.getBoundingClientRect()` returns viewport-relative coordinates. For absolute positioning in a scrollable document, add `window.scrollY` / `window.scrollX`. `@floating-ui/react` (~3KB) is a lightweight alternative for robust edge-aware positioning.
- `mouseup` alone doesn't catch keyboard-based text selection (Shift+Arrow). Need supplemental `keyup` listener or debounced `selectionchange` as fallback.
- Touch devices present a UX conflict: mobile browsers show their own native selection toolbar above selected text, which competes with a custom comment anchor UI.
- Tools like Hypothes.is allow commenting anywhere (no restriction), but GitDoc is constrained by GitHub's diff-line limitation. This is a unique UX challenge — most document annotation tools don't have "non-commentable" regions.
- GitHub's own diff view uses a hover-triggered "+" icon in the gutter for commentable lines — a progressive disclosure pattern. GitDoc should adapt this to a rendered document context with subtler indicators.
- The best visual indicator approach is "layered": always-visible but subtle gutter markers for commentable regions, interactive hover highlights, and clear selection-time feedback. This balances discoverability with reading-focused design.
- Using `data-commentable` as a computed attribute on rendered elements (cross-referencing source lines with the commentableLines set) is the cleanest integration point — it extends the existing `data-source-start`/`data-source-end` approach from the rehype plugin.
- Full background tinting or opacity dimming of non-commentable regions hurts readability — incompatible with the "reading first" principle from the PRD's Google Docs-style interaction model.
- GitHub API comment attribution: when using an OAuth App token, the comment `user` field is the authenticated user with no visual badge. When using a GitHub App user-access token, the user's avatar gets a small identicon badge overlay; audit logs still list the user as actor with `programmatic_access_type: "GitHub App user-to-server token"`. Installation tokens create comments as `app-name[bot]` — not suitable for GitDoc.
- OAuth App tokens do NOT expire by default — they persist until the user revokes access or the client secret is reset. GitHub App user-access tokens expire after 8 hours with a 6-month refresh token.
- OAuth Apps require the broad `repo` scope for private repo access (covers code, PRs, commit statuses, webhooks, etc.). There's no finer scope for just PR comments. `public_repo` works for public repos only. GitHub Apps use fine-grained permissions: `pull_requests: write` + `contents: read` is sufficient.
- GitHub officially recommends GitHub Apps over OAuth Apps for all new projects due to fine-grained permissions and short-lived tokens.
- SAML SSO caveat: if an org uses SAML SSO, users must have an active SAML session before the GitHub App user-access token can access org resources. The app should detect 403s and guide users to re-authenticate.
- GitHub serves raw file content at `https://raw.githubusercontent.com/{owner}/{repo}/{ref}/{path}`. The `{ref}` can be a branch name or commit SHA. SHA is preferred for consistency.
- `react-markdown` provides a `urlTransform` prop — a function `(url, key, node) => string` called for every URL in the rendered output. It applies to both `img[src]` and `a[href]`. The default transform (`defaultUrlTransform`) follows GitHub's safety rules (allows `http`, `https`, `mailto`, etc.).
- The `urlTransform` applies to inline HTML images too (when using `rehype-raw`), not just markdown syntax images.
- `raw.githubusercontent.com` requires authentication for private repos — can't just rewrite URLs for private repos without a proxy or token.
- Relative paths like `../assets/img.png` can be resolved using the `URL` constructor with a base URL, which handles `..` traversal correctly.
- For relative links to `.md` files, rewriting to `raw.githubusercontent.com` would serve raw markdown text (not rendered) — need to rewrite those differently (e.g., to GitHub blob view or internal GitDoc route).
- Tailwind's Preflight CSS reset strips default HTML element styles (heading sizes, list bullets, etc.), which breaks `react-markdown` output. The `@tailwindcss/typography` plugin provides `prose` classes to restore beautiful typographic defaults on arbitrary HTML content.
- shadcn/ui copies component source into your codebase (not an npm dependency) — full ownership, easy to customize, no version upgrade burden. It's built on Radix UI primitives which handle WAI-ARIA accessibility, focus management, and keyboard navigation.
- shadcn/ui's `Sidebar` component supports `side="right"` but is designed for app navigation (collapsible, responsive). For a static document comment margin, a simpler Tailwind flex/grid layout with `ScrollArea` may be more appropriate.
- The `prose` class from `@tailwindcss/typography` sets a default `max-width` for readability — need `max-w-none` to override it when using a custom two-column layout.
- Vercel is the most integrated Next.js hosting platform (built by the same team). Zero-config deployment, serverless functions for API routes, preview URLs per PR, and encrypted env vars. Usage-based pricing; free/hobby tier sufficient for small tools.
- Next.js `output: 'standalone'` in `next.config.js` produces a minimal self-contained Node.js server suitable for Docker containers — the portable fallback if Vercel isn't an option.
- OpenNext is a community project that bundles Next.js for AWS Lambda + CloudFront, providing serverless benefits on AWS without Vercel. More operational overhead.
- Edge Runtime on Vercel has limitations — crypto APIs differ from Node.js, so libraries like `next-auth` and `iron-session` may not work on Edge. Start with Node.js runtime for auth-related routes.
- GitHub REST API rate limit: 5,000 requests/hour per authenticated user (OAuth or GitHub App user-access token). Each user has their own budget — no shared pool. GHEC org-owned apps get 15,000/hour.
- GitHub supports conditional requests via `ETag`/`If-None-Match` and `Last-Modified`/`If-Modified-Since` headers. A 304 response does NOT count against the primary rate limit (when `Authorization` header is present). This is the single most impactful rate-limit optimization.
- Secondary rate limits exist: max 100 concurrent requests, max 900 points/minute for REST (GET=1 point, POST/PATCH/PUT/DELETE=5 points), max 90s CPU time per 60s real time.
- File content fetched at a specific commit SHA is immutable — the same SHA always returns the same bytes. This makes SHA-keyed caching extremely effective with no invalidation needed.
- `lru-cache` npm package provides bounded in-memory caching with configurable max entries, max size, and per-entry TTL. Good fit for Next.js API route caching.
- On Vercel serverless, function instances are reused for a period ("warm") but may be recycled at any time ("cold start"). In-memory caches are lost on cold starts. Vercel KV (Redis-compatible) or Upstash Redis provide persistent caching across invocations if needed.
- Next.js `fetch` in Server Components/API routes can use `cache: 'force-cache'` and `next.revalidate` for built-in data caching, but this is per-route/per-fetch and doesn't give us fine-grained control over GitHub-specific caching semantics (SHA-keyed immutability, ETag forwarding). A custom caching layer in API routes is more appropriate.
- SWR and TanStack Query both provide client-side stale-while-revalidate, request deduplication, and focus revalidation — ideal for the frontend data fetching layer from our API proxy.
- GitHub has TWO different diff endpoints with different failure modes: `GET /pulls/{n}` (with diff Accept header) fails entirely with `406` for large PRs (>300 files, >20K lines, >1MB). `GET /pulls/{n}/files` is more resilient — it still returns file metadata but silently omits the `patch` field on files whose individual diff exceeds ~500KB.
- The `patch` field on each file object in the List PR files response is OPTIONAL. It's absent (not null, just missing from the JSON) when the individual file's diff is too large. The file's `additions`, `deletions`, `changes`, `status`, and other metadata fields are still present.
- GitHub enforced a 300-file diff limit on the `GET /pulls/{n}` endpoint circa March 2024 (confirmed by multiple open-source projects encountering `406` errors). The error message suggests using the List PR files endpoint as a workaround.
- There is NO GitHub API endpoint that provides uncapped or larger diffs. All diff-serving endpoints share the same underlying limits. The only workaround for very large per-file diffs is to compute the diff locally (fetch base + head versions and diff in JS).
- The `GET /repos/{owner}/{repo}/contents/{path}?ref={sha}` endpoint for fetching file content has NO diff-related limits — it always works regardless of diff size. So GitDoc can always render the markdown; it's only the commenting/diff-mapping that degrades.
- Auth.js (next-auth) joined Better Auth in September 2025. Auth.js is now in **maintenance mode** — security patches only, no v5 stable release expected. Better Auth is the recommended successor for new projects requiring comprehensive auth.
- Better Auth supports stateless sessions without a database (new feature), but this mode is less battle-tested. By default it requires a database, which conflicts with GitDoc's stateless architecture.
- `iron-session` v8+ fully supports Next.js App Router via `getIronSession(cookies(), options)` in Server Components, Route Handlers, and Server Actions. It also provides `iron-session/edge` for Edge Runtime compatibility.
- `iron-session` uses `@hapi/iron` for encryption (AES-256-CBC + HMAC-SHA-256) — the same cryptographic approach used by Auth0's session management. Cookie data is encrypted and tamper-proof.
- GitHub OAuth flow is extremely simple (3 HTTP exchanges: redirect → callback with code → exchange code for token). No OIDC complexity, no ID tokens, no PKCE required for server-side flow. Manual implementation is ~50 lines.
- Better Auth had a CVE-2025-61928 (CVSS 9.3) in late 2025 related to unauthenticated API key creation — a reminder that more complex auth libraries have larger attack surfaces.
- Fenced code blocks in the remark/rehype pipeline produce a single `pre > code > text` hast node. The entire code content is one text node with `\n` characters — no per-line position data exists in the default hast tree.
- The `remark-rehype` code handler (`mdast-util-to-hast/lib/handlers/code.js`) appends a trailing `\n` to all code blocks (`const value = node.value ? node.value + '\n' : ''`), which affects line counting.
- After syntax highlighting (`rehype-highlight` or Prism), code content becomes nested `<span>` tokens separated by `\n` text nodes — NOT split by lines. Line-wrapping requires a separate plugin step.
- `rehype-prism-plus` (~780K weekly downloads) wraps each code line in `<div class="code-line" line="N">`. `rehype-highlight-code-lines` (14 stars) wraps in `<span class="code-line" data-line-number="N">`. Both use 1-indexed line numbers within the code block (not source file line numbers).
- The `pre` element's `position.start.line` points to the opening fence line (` ```js `), NOT the first line of code content. Code content starts at `position.start.line + 1`. The closing fence is at `position.end.line`.
- For per-line commenting in code blocks, a two-plugin approach works: (1) a line-wrapping plugin splits code into per-line elements, (2) a custom plugin computes `data-source-start = fenceStartLine + 1 + lineIndex` for each line wrapper.
- `closest('[data-source-start]')` from the text selection UX section naturally finds the nearest `<span class="code-line">` wrapper within code blocks, giving per-line resolution without any changes to the selection logic.
- The `selectionchange` event fires universally for ALL selection methods — mouse, keyboard (Shift+Arrow), Caret Browsing (F7), assistive technologies, and programmatic selections. It is the only truly universal selection detection event.
- `selectionchange` fires continuously during keyboard selection (once per Shift+Arrow keystroke) — requires debouncing (~100ms) to avoid jumpy UI. But after `mouseup`, the selection is already finalized — a short delay (~10ms) suffices.
- Hypothesis's `SelectionObserver` pattern tracks `isMouseDown` state to filter out intermediate `selectionchange` events during mouse drag, while still responding to `selectionchange` from non-mouse inputs. This is more robust than trying to add `keyup` listeners for keyboard selection.
- `keyup` is fragile for detecting keyboard-based selection because platform-specific shortcuts vary (macOS Option+Shift+Arrow, Windows Ctrl+Shift+Home, etc.) and assistive technologies may not fire keyboard events at all.
- Google Docs uses a custom editor (not contenteditable in the traditional sense) with its own cursor and selection system, so their event handling isn't directly comparable to web annotation tools.
- Hypothesis uses Shadow DOM for the adder toolbar to isolate it from host page CSS — worth considering for GitDoc's comment anchor, though Tailwind/shadcn provides scoped styling already.
- On mobile (iOS Safari, Android Chrome), `touchend` does NOT fire when the browser enters text selection mode via long-press. The `contextmenu` event fires on long-press, but before the user has finished adjusting selection handles — not useful for determining the final selection.
- `selectionchange` is the ONLY reliable universal event for detecting text selection on mobile. It fires on long-press selection, selection handle dragging, and external keyboard selection identically.
- The Hypothesis client's `SelectionObserver` has NO explicit `touchend`/`touchstart` listeners. It uses only `selectionchange`, `mousedown`, and `mouseup` — touch selection flows through the same 100ms-debounced `selectionchange` code path as keyboard selection.
- Hypothesis positions their "adder" toolbar (Annotate/Highlight buttons) BELOW the selection on touch devices to avoid conflicting with the native selection toolbar (Copy/Paste/Select All) that appears ABOVE. They detect touch via CSS `(pointer: coarse)` media query, not user-agent sniffing.
- Hypothesis adds an extra 10px vertical offset on touch devices when positioning the adder toolbar, to account for selection handles extending below the text.
- `(pointer: coarse)` CSS media query is more reliable than `'ontouchstart' in window` for detecting touch devices — modern laptops with touchscreens report `ontouchstart` but users primarily use a mouse.
- On mobile, when focus shifts to a textarea (e.g., the comment input), browsers may clear the text selection. The selection range must be saved in state before rendering the comment form.
- iOS Safari sometimes fires `selectionchange` with a collapsed selection immediately after a non-collapsed one (when the callout bar renders). The 100ms debounce naturally handles this — the final event wins.
- Mobile PR review is an inherently frictional workflow (long-press → adjust handles → find comment button → type on virtual keyboard), making a desktop-first MVP strategy appropriate.
- **OAuth App and GitHub App tokens are "automatically authorized for SAML SSO"** — per GitHub's official REST API authentication docs. This is NOT the case for Personal Access Tokens (classic), which require manual per-org SSO authorization.
- For GitHub Apps specifically, SAML SSO credential authorizations are created per-org at the time the user authorizes the app. The user must have an active SSO session for each org they want to access. If they don't, the token won't have access to that org's resources — but this is only at initial authorization time.
- The `X-GitHub-SSO` response header appears on `403 Forbidden` responses when SAML SSO is the issue. Two formats: (1) `required; url=https://github.com/orgs/ORG/sso?...` with a direct re-auth URL (expires after 1 hour), (2) `partial-results; organizations=ID1,ID2` when listing across multiple orgs and some are filtered out.
- GitHub may also return `404 Not Found` instead of `403 Forbidden` for SAML-related access issues on private repos (to avoid confirming repo existence). The `X-GitHub-SSO` header is the reliable signal.
- shadcn/ui provides a `Drawer` component (built on Vaul by Emil Kowalski) that implements native-feeling bottom sheets with swipe-to-dismiss gestures. It supports `direction` prop (`top`, `right`, `bottom`, `left`) and snap points for multi-height positions.
- shadcn/ui's recommended pattern for responsive component switching is: `useMediaQuery("(min-width: 768px)")` hook that listens to `matchMedia` events. Renders `Dialog` on desktop and `Drawer` on mobile. Shared `open` state between both variants.
- The `useMediaQuery` hook returns `false` on the server (no `window`), which can cause SSR hydration mismatches. Best mitigated by using CSS-only hiding (`hidden md:block`) for the initial layout structure and only using the hook for interactive behavior.
- Google Docs mobile uses a dedicated Comments view (tap comment count at top → horizontal swipe through threads) rather than a side panel. GitHub mobile shows PR comments inline in a "Files Changed" view with tappable line comments. Both confirm that bottom-sheet/drawer is the standard mobile pattern for contextual panels.
- Vaul's snap points (`snapPoints` prop) allow the drawer to "snap" to predefined heights during dragging — useful for peek/half/full patterns common in Apple Maps, Google Maps, etc. For MVP, a single open height is sufficient.
- Tailwind's `@tailwindcss/typography` `prose` classes already handle responsive typography — `prose` (16px base) on mobile, `prose lg:prose-lg` (18px base) on desktop. No custom responsive font sizing needed.
- DOM `Range` objects hold **live references** to DOM nodes (`startContainer`, `endContainer`). If React re-renders and replaces those nodes, the Range becomes orphaned — `getBoundingClientRect()` returns a zero-rect and `closest()` traversal may fail.
- `Range.cloneRange()` creates a new Range pointing to the **same** DOM nodes, not cloned nodes. It does not deep-copy. If the original nodes are removed, the cloned Range is equally stale.
- Browsers clear the document text selection when focus shifts to an input/textarea element. This is especially aggressive on mobile (iOS Safari, Android Chrome always clear). On desktop, behavior is inconsistent — some browsers preserve a dimmed highlight, others clear entirely.
- The correct pattern for annotation tools is "extract early, store as plain data": convert the DOM Range into primitive values (line numbers, text, coordinates) immediately upon selection detection, before any UI state change. This is what Hypothesis does — they compute W3C-style selectors from the Range at selection time, not later.
- To provide visual context after the native selection clears, apply a CSS class to the corresponding `[data-source-start]` elements using the stored line numbers. This mirrors Google Docs' yellow highlight on the passage being commented on.
- The `isCommentFormOpen` state flag is critical: when the user clicks the comment textarea, `selectionchange` fires with a collapsed (empty) selection. Without guarding, `onClearSelection` would wipe the stored line data needed for the API call.
- Radix UI primitives (used by shadcn/ui) follow WAI-ARIA authoring practices out of the box — Popover, Dialog, Collapsible, Tooltip, and Button all ship with correct `role`, `aria-*` attributes, focus management,
- Sonner (shadcn/ui's toast library) already uses `aria-live` regions for its toast notifications — no custom implementation needed for toast-based status messages.

- Researched error handling & optimistic UI for comment submission. Documented GitHub API error codes for `POST /pulls/{n}/comments`: 201 (success), 403 (forbidden/rate limit), 422 (validation). Classified errors into 4 categories: validation (422 — stale SHA, invalid line), auth (401/403 — token expired), rate limit (403+headers/429 — backoff), transient (5xx/network — retry). Designed SWR-based optimistic update using `mutate()` with `optimisticData` + `rollbackOnError`. Designed visual states (pending at 0.6 opacity, error with retry/dismiss buttons). Designed comment draft preservation via `sessionStorage` for cross-page survival. Added reply submission error handling (simpler — no stale SHA risk). Documented integration points with existing SWR cache, Sonner toasts, `aria-live` status regions, and rate limit monitoring. Added 3 new exploration tasks: stale SHA detection, API route structure, and comment threading/display.
- Adding `aria-label` to prose elements (`<p>`, `<h1>`) to indicate commentability is **destructive** — it overrides the element's text content for screen readers. The better pattern is separate visually-hidden `<button>` elements that provide the commenting affordance without polluting the reading flow.
- The WAI-ARIA **feed** pattern (`role="feed"` with `role="article"` children) is the correct semantic model for a dynamically-loaded list of comment threads. It requires `aria-posinset`, `aria-setsize`, `aria-labelledby` on each article, and `aria-busy` on the feed container during updates. Keyboard convention: Page Down/Up to move between articles.
- The WAI-ARIA **disclosure** pattern (which Radix's `Collapsible` implements) requires `aria-expanded` and `aria-controls` on the trigger button, with Enter/Space to toggle visibility. This maps directly to expand/collapse comment threads with replies.
- WCAG 4.1.3 Status Messages (AA) requires that status messages not receiving focus must use `role="status"` (`aria-live="polite"`) or `role="alert"` (`aria-live="assertive"`). The live region element must exist in the DOM **before** the message content is injected — adding both simultaneously may not be announced by screen readers.
- WCAG 1.4.11 Non-text Contrast (AA) requires UI component indicators (like our gutter bars) to have ≥3:1 contrast ratio against adjacent colors. Tailwind's `blue-400` (`#60a5fa`) is borderline (~3.1:1 against white); `blue-500` (`#3b82f6`) at ~4.6:1 is safer.
- WCAG 1.4.13 Content on Hover or Focus (AA) requires that hover/focus-triggered content be dismissible (without moving pointer), hoverable (pointer can move over it), and persistent (stays until trigger is removed or user dismisses). Radix's Tooltip handles all three requirements.
- For comment forms in a document margin, `aria-modal="false"` is correct — users should be able to continue reading the document while composing a comment. A modal dialog (`aria-modal="true"`) would block access to the content, which is inappropriate for an alongside-document comment form.
- Sonner (shadcn/ui's toast library) already uses `aria-live` regions for its toast notifications — no custom implementation needed for toast-based status messages.
- The GitHub `POST /pulls/{n}/comments` endpoint returns 201 (success), 403 (forbidden/rate limit), or 422 (validation failed). Undocumented but observed: 401 (token expired), 404 (repo/PR not found or SAML-masked), 429 (secondary rate limit with `Retry-After` header), 5xx (server errors).
- The most likely 422 error for GitDoc is a **stale `commit_id`**: if the PR branch is force-pushed while the user has the page open, the head SHA changes and the old `commit_id` becomes invalid. GitHub rejects the comment because line numbers may no longer be valid.
- GitHub's 403 response can mean two different things: insufficient permissions OR rate limit exceeded. To distinguish, check `x-ratelimit-remaining: 0` header — if present, it's a rate limit error with `x-ratelimit-reset` indicating when the budget resets.
- SWR's `mutate()` supports optimistic updates natively: pass `optimisticData` (function receiving current cache → returns updated cache), `rollbackOnError` (boolean or function), `populateCache` (merge server response into cache), and `revalidate` (re-fetch after mutation). The `rollbackOnError` can be a function to conditionally skip rollback (e.g., for rate limit errors where we want to retry).
- TanStack Query's alternative approach uses `onMutate` → `onError` → `onSettled` callbacks, with `queryClient.cancelQueries()` to prevent race conditions with background refetches. Both SWR and TanStack Query follow the same conceptual pattern: snapshot → optimistic update → rollback on error → revalidate.
- React 19's `useOptimistic()` hook provides a built-in primitive for optimistic state, but it's lower-level than SWR/TanStack Query's cache-based approach. It requires manual rollback logic and doesn't integrate with data fetching. Better suited for simple UI state (like toggles) rather than server-synced lists.
- For comment draft preservation across page reloads, `sessionStorage` (not `localStorage`) is appropriate — drafts are session-scoped and shouldn't persist across browser sessions. Key format: `gitdoc:draft:{prNumber}:{filePath}:{lineRange}` with 1-hour expiry.
- Reply comments (`POST /pulls/{n}/comments/{id}/replies`) only require `body` — no `commit_id`, `path`, or `line` needed. This makes them less error-prone than new comments (no stale SHA risk). The reply endpoint returns 201 (success) or 404 (parent comment deleted).
- The `GET /repos/{owner}/{repo}/pulls/{pull_number}` response includes `head.sha` (the current HEAD commit of the PR branch) and `state` (`open`, `closed`). Comparing `head.sha` against a stored value is the simplest way to detect when a PR has been updated with new commits or force-pushes.
- GitHub does NOT offer a public WebSocket or SSE API for real-time PR update notifications. Their web UI uses internal channels. Third-party apps must use polling or webhooks.
- GitHub webhooks for `push` events would provide near-real-time detection but require: (1) a server endpoint to receive events, (2) webhook signature verification, (3) a mechanism to push updates to specific browser tabs (WebSocket/SSE from our server). Over-engineered for MVP.
- ETag-based conditional requests (`If-None-Match`) on `GET /pulls/{n}` make frequent polling essentially free — 304 responses don't count against the rate limit when `Authorization` header is present. A 60-second poll interval costs ~0–2 actual rate-limited requests per hour (only charged when the PR is actually updated).
- SWR's `revalidateOnFocus: true` option triggers a re-fetch when the browser tab regains focus, catching updates that happened while the tab was backgrounded without wasting requests during inactivity.
- Auto-refreshing on stale SHA is a bad UX choice: it risks discarding unsaved comment drafts, losing scroll position and reading context, and triggering unnecessary refreshes when the current file wasn't affected by the push. A user-prompted banner ("Refresh Now" / "Dismiss") is the right pattern.

- Designed Next.js API route structure for the GitHub proxy layer. Defined 12 routes total: 4 auth routes (`login`, `callback`, `logout`, `me`), 7 GitHub proxy routes (PR list, PR detail, files with patches, comments GET/POST, reply POST, SHA polling), and 1 content/image proxy route using catch-all segment `[...path]`. Designed shared helpers: `requireAuth()` discriminated union return for auth checks, `githubFetch()` with integrated ETag caching and conditional requests, `classifyGitHubError()` for standardised error classification. Designed `middleware.ts` for optimistic cookie-presence check on `/api/repos/*`. Standardised error response format (`{ error, category, retryAfter?, details? }`) that maps directly to the frontend `ApiError` class. Documented the request processing pipeline (8 steps from auth check to JSON response). Response shapes transform GitHub's snake_case to frontend camelCase.

- In Next.js 15+, route handler `params` is a `Promise` that must be awaited — this is a breaking change from Next.js 14 where params were synchronous.
- Next.js middleware runs on every matched route before the route handler. It uses `NextRequest` (not the standard `Request`) and can access cookies via `request.cookies.get()`. It cannot decrypt `iron-session` cookies (needs the full `@hapi/iron` decryption), but can check cookie presence for an optimistic auth gate.
- The `githubFetch()` helper consolidates ETag caching, conditional requests, and error handling into a single function used by all proxy routes. The `cacheKey` override allows SHA-keyed immutable caching (e.g., file content at a specific SHA uses `{owner}/{repo}/{sha}/{path}` as key regardless of the full URL).
- The `classifyGitHubError()` function must check rate-limit headers BEFORE checking the status code for 403, because GitHub returns 403 for both "forbidden" and "rate limit exceeded" — the `x-ratelimit-remaining: 0` header distinguishes them.
- The contents route uses Next.js catch-all segment `[...path]` to handle arbitrarily nested file paths. The path segments arrive as an array (e.g., `['docs', 'guide', 'intro.md']`) and must be joined with `/`.
- Server-side filtering of PR files to `.md`/`.mdx` extensions reduces payload to the frontend and avoids sending large diff patches for non-markdown files the frontend will never render.
- The image proxy for private repos reuses the same contents route — when the file extension indicates an image, the route fetches with `Accept: application/vnd.github.raw+json` and streams raw bytes with appropriate `Content-Type` header and immutable `Cache-Control`.

- GitHub REST API returns PR review comments as a flat list — there is NO "thread" or "conversation" grouping concept in the REST API. Threading must be constructed client-side using the `in_reply_to_id` field. Top-level comments have `in_reply_to_id: null`; replies reference the top-level comment directly. Replies to replies are NOT supported by the API.
- The "resolved" state for comment threads is ONLY available via the GraphQL API (`PullRequestReviewThread.isResolved`). The REST API has no field for this. The `resolveReviewThread` and `unresolveReviewThread` GraphQL mutations toggle resolution. To cross-reference GraphQL threads with REST comments, use the GraphQL `databaseId` field (equals the REST `id`), NOT the GraphQL `id` field (which is the `node_id`).
- Comments with `subject_type: "file"` are file-level comments (no line number) — they should be shown at the top of the comment sidebar, not anchored to a specific passage.
- Google Docs and similar document editors do NOT lock sidebar scroll to document scroll. Comments are positioned via a push-apart algorithm and the sidebar scrolls independently. Connection is via hover-highlighting and click-to-scroll. This is the correct pattern for GitDoc.
- For overlapping thread cards in the right margin, a simple greedy push-apart algorithm (process top-to-bottom, push each card below the previous card's bottom + gap if overlap) works well for the typical case. A full constraint-satisfaction or force-directed layout is unnecessary.
- `element.scrollIntoView({ behavior: 'smooth', block: 'center' })` is the standard way to implement click-to-scroll sync — centers the target element in the viewport rather than snapping to top.
- GitHub GraphQL API's `PullRequest.reviewThreads` connection returns threads pre-grouped with nested `comments`, `isResolved`, `isOutdated`, `resolvedBy`, and viewer permission fields (`viewerCanResolve`, `viewerCanUnresolve`). This is strictly superior to the REST flat comment list for reading comment data — eliminates manual threading via `in_reply_to_id`.
- The `resolveReviewThread` and `unresolveReviewThread` GraphQL mutations both take a single `threadId: ID!` input — the GraphQL node ID of the `PullRequestReviewThread`. This ID is only available from GraphQL queries, not from REST.
- `PullRequestReviewComment.databaseId` (GraphQL `Int`) equals the REST API `id`. It's deprecated in favour of `fullDatabaseId` (`BigInt`), with removal scheduled for 2024-07-01 UTC — but still functional as of Feb 2026. GitHub often extends deprecation timelines.
- GraphQL rate limits: 5,000 points/hour per user (same budget as REST). A query with `reviewThreads(first: 100)` containing `comments(first: 100)` costs ~2 points. Mutations cost 5 points each for secondary rate limit calculations.
- GraphQL responses don't support ETags (they use POST requests). Caching must use application-level TTL, not conditional requests. This contrasts with REST where ETag-based 304s are "free" against the rate limit.
- GraphQL errors return HTTP 200 OK with an `errors` array in the response body — unlike REST which uses HTTP status codes. Must check `json.errors` in the response handler.
- The `addPullRequestReviewComment` GraphQL mutation is deprecated — GitHub recommends `addPullRequestReviewThread` (for new threads) and `addPullRequestReviewThreadReply` (for replies). REST `POST /pulls/{n}/comments` remains the simpler option for creating comments.
- No special GraphQL client library is needed — GitHub's GraphQL endpoint (`POST https://api.github.com/graphql`) accepts standard JSON with `{ query, variables }` body and the same `Authorization: Bearer {token}` header as REST.
- The `reviewThreads` connection does NOT support filtering by file path — client-side filtering by `path` field is required, same as REST.

- Researched comment threading & display. Designed the full comment threading model: GitHub REST API returns a flat list of comments with `in_reply_to_id` for threading (single-level replies only — no replies to replies). Designed `buildCommentThreads()` function to group flat comments into `CommentThread` objects keyed by top-level comment ID, filtered by file path and `side: RIGHT`. Designed a push-apart layout algorithm for positioning thread cards in the right margin aligned with their target source lines, handling overlapping threads by pushing lower cards down with a minimum gap. Designed bidirectional hover-sync (hover thread → highlight passage, hover passage → highlight thread) and click-to-scroll sync. Rejected scroll-position locking (Google Docs doesn't do it either). Discovered that "resolved" thread state is only in the GraphQL API (`PullRequestReviewThread.isResolved`), not REST — MVP will skip this. Added two new exploration tasks: outdated comment handling and GraphQL integration for thread resolution.

- Researched outdated comment handling after force-pushes. Key findings: REST API `line` field becomes `null` when GitHub can't remap a comment to the current diff — this is the primary "outdated" signal. `original_line` and `original_commit_id` always preserve the original values. The `diff_hunk` field preserves the original diff context even on outdated comments. GraphQL provides an explicit `PullRequestReviewThread.isOutdated` (`Boolean!`) and `PullRequestReviewComment.outdated` (`Boolean!`). Designed display strategy: outdated threads grouped in a separate "Outdated Comments" section at bottom of sidebar (not approximate-positioned via `originalLine` — too unreliable after significant rewrites). Collapsed by default, dimmed with `opacity: 0.6` and "Outdated" badge. Show `diff_hunk` as code block on expand. Replies to outdated threads work via the reply endpoint (no `commit_id` needed). Updated `ReviewComment` interface with `originalLine`, `originalCommitId`, `commitId`, `diffHunk` fields.

- Researched GraphQL integration for thread resolution state. Designed a complete GraphQL query using `PullRequest.reviewThreads` connection that returns threads pre-grouped with nested comments, `isResolved`, `resolvedBy`, `isOutdated`, `viewerCanResolve`/`viewerCanUnresolve` permissions. **Recommended replacing the REST comments endpoint with GraphQL** as the primary data source for comments — threads come pre-grouped (eliminates manual `in_reply_to_id` assembly), resolution and outdated states are explicit, viewer permissions are included. REST retained only for creating new comments and replies (simpler APIs). Designed `resolveReviewThread`/`unresolveReviewThread` mutations (require GraphQL thread `id`), updated `CommentThread` data model with `graphqlId`, resolution fields, viewer permissions. Added 3 new API routes: threads GET (GraphQL proxy), resolve POST, unresolve POST. Designed a minimal `githubGraphQL()` helper (no library needed). Noted that GraphQL responses don't support ETags — cache by PR number with short TTL.
